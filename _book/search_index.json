[["index.html", "BSOL R Guide Chapter 1 Loading data from file 1.1 Read from CSV 1.2 Read from excel", " BSOL R Guide Archie Atack 2024-09-30 Chapter 1 Loading data from file 1.1 Read from CSV library(tidyverse) csv_data &lt;- read_csv(&quot;data.csv&quot;) read_csv() is found in the readr package (part of tidyverse) and is an improved version of the base R function read.csv(). csv_data &lt;- read_csv( &quot;data.csv&quot;, col_types = cols( # specify data types col1 = col_character(), col2 = col_double(), col3 = col_date(), col4 = col_datetime(), col5 = col_time(), col6 = col_logical() ) ) Use the col_types argument to specify data types. See the documentation for cols() to see the possible types. If the col_types argument is left blank, read_csv estimates an appropriate data type for each column using the first 1000 rows of data. Amend the guess_max argument to adjust the number of rows used to estimate type. Use col_types = cols() to suppress the output message to the console. Use cols_only instead of cols() to only specify the data types of a subset of the columns. 1.2 Read from excel library(readxl) excel_data &lt;- read_xlsx(&quot;data.xlsx&quot;) readxl is downloaded as part of the tidyverse packages but needs to be called specifically to load in its functions. By default, readxl will load in the first sheet of the workbook. To read in xls files, use either read_excel() or read_xls(). excel_data &lt;- read_xlsx( &quot;data.xlsx&quot;, sheet = &quot;Sheet1&quot;, range = &quot;A1:D20&quot; ) excel_data &lt;- read_xlsx( &quot;data.xlsx&quot;, sheet = &quot;Sheet1&quot;, skip = 3, n_max = 100 ) Use the sheet, range, skip, n_max etc arguments to specify the range of data to read. excel_data &lt;- read_xlsx( &quot;data.xlsx&quot;, sheet = &quot;Sheet1&quot;, range = &quot;A1:D20&quot;, col_types = c(&quot;text&quot;,&quot;numeric&quot;,&quot;date&quot;,&quot;guess&quot;) ) Use the col_types argument to specify data types. See the documentation for list of all possible types. "],["writing-data-to-file.html", "Chapter 2 Writing data to file 2.1 Write to CSV 2.2 Write to excel", " Chapter 2 Writing data to file 2.1 Write to CSV library(tidyverse) write_csv(data, &quot;data.csv&quot;) write_csv() is found in the readr package (part of tidyverse) and is an improved version of the base R function write.csv(). Use the na argument to specify how NULL or NA values should be represented. 2.2 Write to excel library(openxlsx) write.xlsx(data, &quot;data.xlsx&quot;, sheetName = &quot;Summary&quot;) The openxlsx enables data to be written to excel files. Use the asTable argument to specify if the data should be stored in a table within excel. See the write.xlsx documentation for various options to customise the workbook aesthetics from R. "],["interact-with-sql-server.html", "Chapter 3 Interact with SQL Server 3.1 SQL connection 3.2 Read data using SQL 3.3 Read data using existing script 3.4 Execute SQL from R 3.5 Create static table 3.6 Create temp table 3.7 Delete tables", " Chapter 3 Interact with SQL Server 3.1 SQL connection library(odbc) sql_connection &lt;- dbConnect( odbc(), Driver = &quot;SQL Server&quot;, Server = &quot;MLCSU-BI-SQL&quot;, Database = &quot;EAT_Reporting_BSOL&quot;, Trusted_Connection = &quot;True&quot; ) odbc is a package that allows R to connect to the SQL server databases. 3.2 Read data using SQL library(DBI) library(tidyverse) sql_data &lt;- dbGetQuery( sql_connection, &quot;SELECT * FROM table&quot; ) %&gt;% as_tibble() # converts output to tibble for practicality The DBI package allows R to interact with the data in SQL server. The dbGetQuery() function outputs the data as a dataframe. Therefore the dataframe is then converted to a tibble using as_tibble() for practicality (tibbles print tidier outputs to the console). 3.3 Read data using existing script sql_data &lt;- dbGetQuery( sql_connection, readr::read_file(&quot;script.sql&quot;) ) %&gt;% as_tibble() The read_file() function from readr allows an existing SQL script in the file directory to be run from RStudio and will load the results of the query into R. 3.4 Execute SQL from R dbExecute( sql_connection, &quot;SELECT * INTO ##temp FROM table&quot; ) Use this when creating temp tables in SQL server or running stored procedures from R. 3.5 Create static table dbWriteTable( sql_connection, Id(schema = &quot;dbo&quot;, table = &quot;BSOL_XXXX_example&quot;), data, overwrite = TRUE, field.types = c( col1 = &quot;varchar(50)&quot;, col2 = &quot;int&quot;, col3 = &quot;date&quot; ) ) The dbWriteTable() function can be used to create tables in SQL Server from R. To specify the naming convention of the table to be made, the below functions can be used: - Database name: the database specified in the original sql_connection using dbConnect() - Schema and table name: the Id() function is used to specify the schema and table name If the schema is not specified using the Id function, R will use the default schema for that database (usually dbo). Use the overwrite argument to enable overwrites of the table. Use the field.types argument to specify the data types to applied to each column when loading the data into R. If the field.types are not specified, SQL will estimate an appropriate data type to use - !warning! sql will use varchar(255) for all character columns, therefore it is recommended that data types are specified for larger tables. 3.6 Create temp table dbWriteTable( sql_connection, &quot;##BSOL_XXXX_example&quot;, data ) To create a temp table, the schema and database do not have to be specified. 3.7 Delete tables dbRemoveTable( sql_connection, Id(schema = &quot;dbo&quot;, table = &quot;BSOL_XXXX_example&quot;) ) dbRemoveTable(sql_connection, &quot;##BSOL_XXXX_example&quot;) The dbRemoveTable() function can be used to remove tables from SQL server. To remove static tables, the database needs to be specified via the sql connection and the schema must also be defined. To remove temp tables, the database and schema do not need to be specified. "],["query-data-using-dplyr.html", "Chapter 4 Query data using dplyr 4.1 Select, head, distinct, and order by 4.2 Filter 4.3 Mutate and update 4.4 Group by and summarise 4.5 Joins and unions 4.6 Case When 4.7 Pivot 4.8 Unpivot 4.9 Across 4.10 Across to retrieve datatypes", " Chapter 4 Query data using dplyr 4.1 Select, head, distinct, and order by library(tidyverse) library(gapminder) gapminder %&gt;% select(country, continent, year, lifeExp, pop) %&gt;% select(-continent, -lifeExp) %&gt;% arrange(year, pop) %&gt;% head(50) gapminder %&gt;% distinct(country, continent, pop) %&gt;% arrange(continent, desc(pop)) The select function allows multiple fields can be selected at once. However dplyr also allows the exclusion of columns - using the minus sign as a prefix will return all columns EXCEPT the stated column. The head function is an equivalent of the SQL TOP statement. Arrange is the equivalent of order by and defaults to ascending order. Use the desc() function to reverse order to descending. 4.2 Filter gapminder %&gt;% filter(country == &quot;United Kingdom&quot; &amp; lifeExp &gt;= 75) %&gt;% filter(year != &quot;1952&quot;) gapminder %&gt;% filter(country %in% c(&quot;Italy&quot;, &quot;France&quot;, &quot;Spain&quot;)) %&gt;% filter(!is.na(year)) gapminder %&gt;% filter(!continent %in% c(&quot;Europe&quot;, &quot;Asia&quot;) | lifeExp &lt; 30) The filter function operates much like the SQL WHERE clause. To identify equality in equations use two equal signs “==”. The &amp; is the AND operator and | is the OR operator. The ! character works as an inverse operator (e.g. != is not equal). Use is.na() to identify null / NA values. Use %in% to filter for multiple values. Ensure a vector (i.e. wrapped in c()) is used when searching for multiple values. 4.3 Mutate and update gapminder %&gt;% mutate( gdp = pop * gdpPercap, row_id = row_number() ) gapminder$year &lt;- as.character(gapminder$year) # converts year from int to character gapminder %&gt;% mutate(year = replace( year, year &lt; 1980, &quot;Pre-1980&quot; )) The mutate function allows new columns to be added to the dataset. The name of the new column is given first and then followed by the value of the column (i.e. opposite to sql where the name comes second). The = symbol is equivalent to AS in sql. The replace statement, combined with mutate, can act as an equivalent of an update statement. It has three arguments: the column being amended, the values to be amended, and the replacement value. Ensure the datatype of the column allows the replacement values. 4.4 Group by and summarise gapminder %&gt;% group_by(year) %&gt;% tally() gapminder %&gt;% group_by(continent, year) %&gt;% summarise(average_population = mean(pop, na.rm = TRUE)) The tally function operates like SUM(1) or COUNT(*) in SQL. The summarise function allows mathematical operations over groups such as sum, mean, median etc. If there are any nulls / NA values in the data, ensure that the sum / mean functions have the na.rm argument set to TRUE. It is good practice to ungroup following aggregation to ensure grouping does not unintentionally impact on further steps in data manipulation. 4.5 Joins and unions gapminder %&gt;% left_join(country_codes, &quot;country&quot;) # join condition if column name same gapminder %&gt;% inner_join(country_codes, c(&quot;country&quot; = &quot;country&quot;)) # join condition if column names differ gapminder %&gt;% filter(year == 1957) %&gt;% union_all( gapminder %&gt;% filter(year == 1962) ) %&gt;% union_all( gapminder %&gt;% filter(year == 1967) ) If the joining column names are the same, the column only needs to be referenced once. If the names are different, both column names need to be specified. 4.6 Case When gapminder %&gt;% distinct(continent) %&gt;% mutate(continent_id = case_when( continent == &quot;Africa&quot; ~ 1, continent == &quot;Asia&quot; ~ 2, TRUE ~ 3 )) The case when statement operates like SQL with slightly different syntax. The tilde symbol is an equivalent of THEN. TRUE is the equivalent of the concluding ELSE statement. 4.7 Pivot life_expectancy &lt;- gapminder %&gt;% select(country, year, lifeExp) life_expectancy %&gt;% pivot_wider( names_from = year, values_from = lifeExp ) Use pivot_wider to pivot rows to columns. The above output pivots years to columns to show a tabular view of life expectancy over time. 4.8 Unpivot # Identify columns to unpivot metric_list &lt;- colnames(gapminder) %&gt;% as_tibble() %&gt;% filter(value %in% c(&quot;lifeExp&quot;,&quot;pop&quot;,&quot;gdpPercap&quot;)) %&gt;% # list pivoting columns .$value # retrieve values as vector # Pivot gapminder %&gt;% pivot_longer( cols = all_of(metric_list), # cols to pivot - all_of helper function needed names_to = &quot;Metric&quot;, values_to = &quot;Value&quot; ) Use the pivot_longer function to unpivot columns to rows. It requires a vector of columns to pivot. Use the above method to hard code the column names. Alternatively, if there is a pattern in the name of columns to pivot (i.e. all include a number), you can use stringr and regular expressions. E.g. colnames(data) %&gt;% sub_set(“\\\\d”) identifies all columns containing a number Regular expression guide with stringr found here https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf). 4.9 Across # Calculate max length gapminder %&gt;% summarise( across( everything(), ~max(str_length(.), na.rm = TRUE) ) ) %&gt;% pivot_longer(cols = everything()) # Update null values with zero gapminder %&gt;% mutate( across( everything(), ~ replace(., is.na(.), 0) ) ) Use across to apply logic to multiple columns in a dataset. The two above examples look at: Calculating max length of all columns Updating all null values with zeros Across takes two key arguments: The first to choose which columns to apply logic to The second to outline the logic to apply. For the first argument, helper functions are useful here - everything() will select all columns. Other examples can be found here - https://tidyselect.r-lib.org/reference/language.html For the second argument, use a full stop (.) in place of a column name to pass through all columns that meet the criteria of the first argument. Ensure that a tilde (~) preceding the function used in the logic is also included. 4.10 Across to retrieve datatypes # Calculate max length no dates gapminder %&gt;% summarise( across( everything(), ~max(str_length(.), na.rm = TRUE) ) ) %&gt;% view() pivot_longer(cols = everything(), values_to = &quot;max_length&quot;) %&gt;% left_join( gapminder %&gt;% sapply(class) %&gt;% # extract datatype from all cols as_tibble(rownames = &quot;name&quot;) %&gt;% rename(data_type = value), &quot;name&quot; ) %&gt;% print(n = ncol(gapminder)) # Calculate max length with dates gapminder %&gt;% summarise( across( everything(), ~max(str_length(.), na.rm = TRUE) ) ) %&gt;% pivot_longer(cols = everything()) %&gt;% left_join( sapply(gapminder, class) %&gt;% as_tibble() %&gt;% head(1) %&gt;% # dates can have two classes - pick only one pivot_longer(cols = everything(), values_to = &quot;data_type&quot;), &quot;name&quot; ) %&gt;% print(n = ncol(gapminder)) "],["string-functions.html", "Chapter 5 String functions 5.1 Stringr 5.2 Example functions", " Chapter 5 String functions 5.1 Stringr The stringr package contains multiple functions to manipulate strings. Stringr is part of the tidyverse collection of packages, and therefore is designed to work with the pipe function. Base R also has a range of functions that allow string manipulation, however the base R functions do not tend to operate well with the pipe and therefore stringr functions are usually preferable. The below dataset of six UK food store locations will be used in the following examples. library(tidyverse) locations &lt;- read_csv(&quot;tortilla_locations.csv&quot;) 5.2 Example functions locations %&gt;% mutate(pc_no_spc = str_replace(postcode, &quot; &quot;, &quot;&quot;)) %&gt;% mutate(pc_length = str_length(pc_no_spc)) %&gt;% mutate(pc_district = case_when( pc_length == 5 ~ str_sub(postcode, 1, 2), pc_length == 6 ~ str_sub(postcode, 1, 3), pc_length == 7 ~ str_sub(postcode, 1, 4), )) %&gt;% mutate(location_pc = paste(location, &quot;-&quot;, pc_district)) The str_replace function replaces matched characters within the string. The str_length function calculates the length of the string. The str_sub function identifies a substring. Equivalent of the LEFT, MID, RIGHT functions in sql etc. The paste functions are part of base R (not stringr) but are useful for concatenation. By default the paste function includes spaces between values. Use the sep argument to change this to a different character, or conversely, if no spaces are required, use the paste0 function. To learn more about other available stringr functions, a useful “cheat sheet” can be found here: https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf "],["creating-charts.html", "Chapter 6 Creating charts 6.1 ggplot2 6.2 Bar chart 6.3 Chart customisation 6.4 Combining chart elements 6.5 Interactive charts", " Chapter 6 Creating charts 6.1 ggplot2 The ggplot2 package, part of the tidyverse collection, is the most popular package in R to create charts. The below dataset of BSOL PCN populations (derived from NHS Digital - Patients Registered at a GP Practice dataset) is used in the following examples. library(tidyverse) pcn &lt;- read_csv(&quot;ggplot2_pcn_pop.csv&quot;) 6.2 Bar chart ggplot( pcn, # data aes(PCN, Population) # x + y values ) + geom_col(fill = &quot;lightgreen&quot;) + coord_flip() The ggplot function begins the chart - this takes the dataset and the variables to be plotted on the x + y axis. The x + y variables have to be wrapped within the aes (aesthetic) function. Please note that because ggplot2 was one of the first designed tidyverse packages, it does not currently operate with the pipe. Instead it uses the + sign, which works in a similar fashion to the pipe. To specify the type of chart, a geom_ function is required - geom_col in this case. Use the fill argument to change the colour of the columns - by default it will be grey. As there are a large number of PCN labels for the x-axis, the labels will overlap. Therefore the coord_flip() function is used to flip PCN to the x-axis and enable the labels to be readable. 6.3 Chart customisation ggplot( pcn, aes( reorder(PCN, Population), # order PCN by population Population ) ) + geom_col(fill = &quot;lightgreen&quot;) + coord_flip() + xlab(&quot;PCN&quot;) + # rename PCN axis scale_y_continuous(expand = c(0, 0)) # remove space ggplot2 allows significant chart customisation, the above code includes a few examples: Use the reorder function when the x + y variables are called to order the columns. Use the xlab or ylab functions to rename each axis. When the reorder function is used, the axis will be renamed reorder(x,y) - the xlab function allows this to be corrected. Use the code scale_y_continuous(expand = c(0,0)) to remove the space between the PCN labels and the columns. 6.4 Combining chart elements average_pop &lt;- mean(pcn$Population) ggplot( pcn, aes( reorder(PCN, Population), Population ) ) + geom_col(fill = &quot;lightgreen&quot;) + coord_flip() + xlab(&quot;PCN&quot;) + geom_hline(yintercept = average_pop, color = &quot;blue&quot;) + # avg population scale_y_continuous(expand = c(0, 0)) Multiple elements can be added to the chart. The above code adds a benchmark line to indicate average PCN population. The average population can be derived and then passed through to the geom_hline function to indicate the PCN average. 6.5 Interactive charts library(plotly) ggplotly( ggplot( pcn, aes( reorder(PCN, Population), Population, text = paste0( # customisable tooltip using html &quot;PCN: &quot;, PCN, &quot;&lt;br&gt;&quot;, &quot;Population: &quot;, Population, &quot;&lt;br&gt;&quot;, Group ) ) ) + geom_col(fill = &quot;lightgreen&quot;) + coord_flip() + xlab(&quot;PCN&quot;) + geom_hline(yintercept = average_pop, color = &quot;blue&quot;) + scale_y_continuous(expand = c(0, 0)), tooltip = &quot;text&quot; # ensures tooltip is changed ) %&gt;% config(displayModeBar = F) The plotly package converts ggplot2 plots to interactive charts. Simply wrap the existing ggplot2 code in the ggplotly function. To edit the tooltip, edit the text argument within the aes() function. This can take html for formatting. Ensure tooltip = “text” is included at the end of the ggplotly function. To turn off the option buttons created by plotly, use %&gt;% config(displayModeBar = F). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
